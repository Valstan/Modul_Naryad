Карта проекта:
conftest.py
main.py
print_proekt.py
db\backup.py
db\database.py
db\queries.py
gui\base_form.py
gui\dialogs.py
gui\employees_form.py
gui\main_window.py
gui\work_order_form.py
reports\excel_report.py
reports\html_report.py
reports\pdf_report.py
tests\test_database.py
utils\validators.py

--------------------------------------------------------------------------------

Путь: conftest.py
Имя файла: conftest.py
Содержимое:
# conftest.py (в корне проекта)
import sys
from pathlib import Path

# Добавляем корневую директорию в путь поиска модулей
root_dir = Path(__file__).parent
sys.path.append(str(root_dir))
--------------------------------------------------------------------------------
Путь: main.py
Имя файла: main.py
Содержимое:
# main.py
from db.backup import BackupManager
from gui.dialogs import show_error
from gui.main_window import MainWindow


def main() -> None:
    """Точка входа в программу."""
    try:
        # Создать резервную копию БД при запуске
        BackupManager("work_orders.db").create_backup()

        # Инициализация GUI
        app = MainWindow()
        app.mainloop()

    except Exception as e:
        show_error(f"Критическая ошибка: {str(e)}")


if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
Путь: print_proekt.py
Имя файла: print_proekt.py
Содержимое:
import os

def create_project_map(project_root):
    project_map = []
    for root, dirs, files in os.walk(project_root):
        if '.venv' in dirs:
            dirs.remove('.venv')  # Исключаем папку .venv из сканирования
        for file in files:
            if file.endswith('.py'):
                file_path = os.path.join(root, file)
                project_map.append(os.path.relpath(file_path, project_root))
    return project_map

project_root = os.getcwd()  # Корневая директория проекта
output_file = os.path.join(project_root, "project_contents.txt")

# Создаем карту проекта
project_map = create_project_map(project_root)

with open(output_file, 'w', encoding='utf-8') as f:
    # Записываем карту проекта
    f.write("Карта проекта:\n")
    for file_path in project_map:
        f.write(f"{file_path}\n")
    f.write('\n' + '-' * 80 + '\n\n')

    # Записываем содержимое файлов
    for file_path in project_map:
        full_path = os.path.join(project_root, file_path)
        with open(full_path, 'r', encoding='utf-8') as src_file:
            content = src_file.read()

        f.write(f"Путь: {file_path}\n")
        f.write(f"Имя файла: {os.path.basename(file_path)}\n")
        f.write("Содержимое:\n")
        f.write(content)
        f.write('\n' + '-' * 80 + '\n')

print(f"Информация о проекте сохранена в файл: {output_file}")
--------------------------------------------------------------------------------
Путь: db\backup.py
Имя файла: backup.py
Содержимое:
# db/backup.py
import os
import shutil
from pathlib import Path
from datetime import datetime
from typing import Optional


class BackupManager:
    """Управление резервными копиями БД с проверкой существования файла."""

    def __init__(self, db_path: str, backup_dir: str = "backups", max_backups: int = 20):
        self.db_path = Path(db_path)
        self.backup_dir = Path(backup_dir)
        self.max_backups = max_backups

        if not self.db_path.exists():
            raise FileNotFoundError(f"Файл БД {db_path} не найден!")

        self._ensure_backup_dir()

    def _ensure_backup_dir(self) -> None:
        """Создать директорию для резервных копий."""
        self.backup_dir.mkdir(exist_ok=True, parents=True)

    def create_backup(self) -> Optional[str]:
        """Создание резервной копии с обработкой ошибок."""
        try:
            # Генерация имени файла
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_path = self.backup_dir / f"backup_{timestamp}.db"

            # Копирование файла
            shutil.copy2(str(self.db_path), str(backup_path))
            self._cleanup_old_backups()
            return str(backup_path)

        except Exception as e:
            print(f"Ошибка резервного копирования: {str(e)}")
            return None

    def _cleanup_old_backups(self) -> None:
        """Удаление старых копий, если превышен лимит."""
        backups = sorted(
            self.backup_dir.glob("backup_*.db"),
            key=lambda x: x.stat().st_mtime,
            reverse=False
        )

        while len(backups) > self.max_backups:
            old_backup = backups.pop(0)
            os.remove(str(old_backup))
--------------------------------------------------------------------------------
Путь: db\database.py
Имя файла: database.py
Содержимое:
# db/database.py
import logging
import sqlite3
from pathlib import Path
from typing import Optional, List, Tuple, Any

logger = logging.getLogger(__name__)


class Database:
    """Singleton для управления подключением к SQLite."""
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._init_db()
        return cls._instance

    def _init_db(self) -> None:
        """Инициализация БД с автоматическим созданием файла."""
        self.db_path = Path("work_orders.db")
        self.db_path.touch(exist_ok=True)
        self.conn = sqlite3.connect(str(self.db_path))
        self.conn.execute("PRAGMA foreign_keys = ON")
        self._create_tables()

    def _create_tables(self) -> None:
        """Создание таблиц из SQL-файла."""
        sql_file = Path(__file__).parent / "queries.sql"
        if sql_file.exists():
            with open(sql_file, "r") as f:
                sql = f.read()
            cursor = self.conn.cursor()
            try:
                cursor.executescript(sql)
                self.conn.commit()
            except sqlite3.Error as e:
                logger.error(f"Ошибка создания таблиц: {str(e)}")
                self.conn.rollback()
            finally:
                cursor.close()

    def execute_query(
            self,
            query: str,
            params: Optional[Tuple[Any, ...]] = None
    ) -> Optional[List[Tuple[Any, ...]]]:
        """
        Безопасное выполнение SQL-запроса с поддержкой транзакций.

        Returns:
            Список кортежей с результатами запроса или None при ошибке.
        """
        cursor = self.conn.cursor()
        try:
            cursor.execute("BEGIN TRANSACTION")
            if params:
                cursor.execute(query, params)
            else:
                cursor.execute(query)
            result = cursor.fetchall()
            self.conn.commit()
            return result
        except sqlite3.Error as e:
            self.conn.rollback()
            logger.error(f"Ошибка выполнения запроса: {str(e)}")
            return None  # Явный возврат None при ошибке
        finally:
            cursor.close()

    def __del__(self) -> None:
        """Закрытие соединения при удалении объекта."""
        if hasattr(self, "conn"):
            self.conn.close()
--------------------------------------------------------------------------------
Путь: db\queries.py
Имя файла: queries.py
Содержимое:
# db/queries.py
REPORT_BASE_QUERY = """
SELECT
    wo.id AS order_id,
    wo.order_date,
    p.name AS product,
    c.contract_code,
    SUM(owt.amount) AS total_amount,
    GROUP_CONCAT(e.full_name, ', ') AS workers
FROM work_orders wo
LEFT JOIN products p ON wo.product_id = p.id
LEFT JOIN contracts c ON wo.contract_id = c.id
LEFT JOIN order_workers ow ON wo.id = ow.order_id
LEFT JOIN employees e ON ow.worker_id = e.id
LEFT JOIN order_work_types owt ON wo.id = owt.order_id
GROUP BY wo.id
"""

WORK_ORDERS_FOR_PDF_HTML = """
SELECT
    wo.id AS order_id,
    wo.order_date,
    p.name AS product,
    c.contract_code,
    SUM(owt.amount) AS total_amount
FROM work_orders wo
LEFT JOIN products p ON wo.product_id = p.id
LEFT JOIN contracts c ON wo.contract_id = c.id
LEFT JOIN order_work_types owt ON wo.id = owt.order_id
GROUP BY wo.id
"""
--------------------------------------------------------------------------------
Путь: gui\base_form.py
Имя файла: base_form.py
Содержимое:
# gui/base_form.py
import customtkinter as ctk
from tkinter import ttk
from typing import List, Optional, Tuple
from db.database import Database


class BaseForm(ctk.CTkFrame):
    """Базовый класс для всех форм с таблицей и кнопками управления."""

    def __init__(self, parent: ctk.CTkFrame, db: Database, columns: List[str]):
        super().__init__(parent)
        self.db = db
        self.columns = columns
        self._setup_ui()

    def _setup_ui(self) -> None:
        """Инициализация интерфейса."""
        # Таблица
        self.table = ttk.Treeview(
            self,
            columns=self.columns,
            show="headings",
            style="Custom.Treeview"
        )
        for col in self.columns:
            self.table.heading(col, text=col)
        self.table.pack(expand=True, fill="both", padx=10, pady=10)

        # Кнопки управления
        self.btn_frame = ctk.CTkFrame(self)
        self.btn_frame.pack(pady=10)

        self.add_btn = ctk.CTkButton(self.btn_frame, text="Добавить", command=self._add_item)
        self.add_btn.pack(side="left", padx=5)

        self.edit_btn = ctk.CTkButton(self.btn_frame, text="Редактировать", command=self._edit_item)
        self.edit_btn.pack(side="left", padx=5)

        self.delete_btn = ctk.CTkButton(self.btn_frame, text="Удалить", command=self._delete_item)
        self.delete_btn.pack(side="left", padx=5)

    def _load_data(self, query: str, params: Optional[Tuple] = None) -> None:
        """Загружает данные из БД в таблицу."""
        for row in self.table.get_children():
            self.table.delete(row)
        data = self.db.execute_query(query, params)
        for item in data:
            self.table.insert("", "end", values=item)

    def _add_item(self) -> None:
        """Добавление элемента (реализуется в дочерних классах)."""
        raise NotImplementedError

    def _edit_item(self) -> None:
        """Редактирование элемента (реализуется в дочерних классах)."""
        raise NotImplementedError

    def _delete_item(self) -> None:
        """Удаление элемента (реализуется в дочерних классах)."""
        raise NotImplementedError
--------------------------------------------------------------------------------
Путь: gui\dialogs.py
Имя файла: dialogs.py
Содержимое:
# gui/dialogs.py
from tkinter import ttk

import customtkinter as ctk
from tkcalendar import Calendar
from datetime import datetime
from typing import List, Optional, Tuple
from db.database import Database


class DatePickerDialog(ctk.CTkToplevel):
    """Диалоговое окно выбора даты."""

    def __init__(self, parent: ctk.CTkFrame) -> None:
        super().__init__(parent)
        self.title("Выбор даты")
        self.geometry("300x200")
        self.resizable(False, False)
        self._selected_date: Optional[datetime] = None

        # Календарь из tkcalendar
        self.calendar = Calendar(self, selectmode="day", date_pattern="dd.mm.yyyy")
        self.calendar.pack(pady=10)

        # Кнопки
        self.btn_frame = ctk.CTkFrame(self)
        self.btn_frame.pack(pady=10)

        self.ok_btn = ctk.CTkButton(self.btn_frame, text="OK", command=self._on_ok)
        self.ok_btn.pack(side="left", padx=5)

        self.cancel_btn = ctk.CTkButton(self.btn_frame, text="Отмена", command=self.destroy)
        self.cancel_btn.pack(side="right", padx=5)

    def _on_ok(self) -> None:
        """Обработка выбора даты."""
        try:
            self._selected_date = datetime.strptime(self.calendar.get_date(), "%d.%m.%Y")
            self.destroy()
        except ValueError:
            self._selected_date = None

    def get_date(self) -> Optional[datetime]:
        """Возвращает выбранную дату."""
        return self._selected_date


class WorkerSelectionDialog(ctk.CTkToplevel):
    """Диалоговое окно выбора рабочих."""

    def __init__(self, parent: ctk.CTkFrame, db: Database) -> None:
        super().__init__(parent)
        self.title("Выбор рабочих")
        self.geometry("600x400")
        self.db = db
        self._selected_ids: List[int] = []
        self._setup_ui()

    def _setup_ui(self) -> None:
        """Инициализация интерфейса."""
        # Таблица работников
        self.tree = ttk.Treeview(self, columns=("id", "name", "workshop"), show="headings")
        self.tree.heading("id", text="Табельный №")
        self.tree.heading("name", text="ФИО")
        self.tree.heading("workshop", text="Цех")
        self.tree.pack(expand=True, fill="both", padx=10, pady=10)

        # Загрузка данных
        workers = self.db.execute_query("SELECT employee_id, full_name, workshop_number FROM employees")
        for worker in workers:
            self.tree.insert("", "end", values=worker)

        # Кнопки
        self.btn_frame = ctk.CTkFrame(self)
        self.btn_frame.pack(pady=10)

        self.select_btn = ctk.CTkButton(self.btn_frame, text="Выбрать", command=self._on_select)
        self.select_btn.pack(side="left", padx=5)

        self.cancel_btn = ctk.CTkButton(self.btn_frame, text="Отмена", command=self.destroy)
        self.cancel_btn.pack(side="right", padx=5)

    def _on_select(self) -> None:
        """Обработка выбранных рабочих."""
        selected_items = self.tree.selection()
        self._selected_ids = [int(self.tree.item(item)["values"][0]) for item in selected_items]
        self.destroy()

    def get_selected_workers(self) -> List[int]:
        """Возвращает список ID выбранных рабочих."""
        return self._selected_ids


def show_error(message: str) -> None:
    """Отображает окно с сообщением об ошибке."""
    dialog = ctk.CTkToplevel()
    dialog.title("Ошибка")
    dialog.geometry("400x100")

    label = ctk.CTkLabel(dialog, text=message, text_color="red")
    label.pack(pady=20)

    btn = ctk.CTkButton(dialog, text="OK", command=dialog.destroy)
    btn.pack(pady=5)


def show_info(message: str) -> None:
    """Отображает информационное сообщение."""
    dialog = ctk.CTkToplevel()
    dialog.title("Информация")
    dialog.geometry("400x100")

    label = ctk.CTkLabel(dialog, text=message)
    label.pack(pady=20)

    btn = ctk.CTkButton(dialog, text="OK", command=dialog.destroy)
    btn.pack(pady=5)
--------------------------------------------------------------------------------
Путь: gui\employees_form.py
Имя файла: employees_form.py
Содержимое:
# gui/employees_form.py
from typing import Optional

import customtkinter as ctk
from db.database import Database
from gui.base_form import BaseForm
from gui.dialogs import show_error, show_info
from utils.validators import validate_unique_employee_id


class EmployeesForm(BaseForm):
    """Форма для управления данными работников."""

    def __init__(self, parent: ctk.CTkFrame, db: Database):
        columns = ["Табельный №", "ФИО", "Цех", "Должность"]
        super().__init__(parent, db, columns)
        self._load_data("SELECT employee_id, full_name, workshop_number, position FROM employees")

    def _add_item(self) -> None:
        """Открытие диалога добавления работника."""
        dialog = EmployeeDialog(self, self.db)
        if dialog.result:
            self._load_data("SELECT employee_id, full_name, workshop_number, position FROM employees")

    def _edit_item(self) -> None:
        """Открытие диалога редактирования работника."""
        selected = self.table.selection()
        if not selected:
            show_error("Выберите работника!")
            return

        employee_data = self.table.item(selected[0])["values"]
        dialog = EmployeeDialog(self, self.db, employee_data)
        if dialog.result:
            self._load_data("SELECT employee_id, full_name, workshop_number, position FROM employees")

    def _delete_item(self) -> None:
        """Удаление выбранного работника."""
        selected = self.table.selection()
        if not selected:
            show_error("Выберите работника!")
            return

        employee_id = self.table.item(selected[0])["values"][0]
        self.db.execute_query("DELETE FROM employees WHERE employee_id = ?", (employee_id,))
        self._load_data("SELECT employee_id, full_name, workshop_number, position FROM employees")


class EmployeeDialog(ctk.CTkToplevel):
    """Диалог для добавления/редактирования работника."""

    def __init__(self, parent: ctk.CTkFrame, db: Database, data: Optional[list] = None):
        super().__init__(parent)
        self.db = db
        self.result = False
        self.title("Данные работника" if not data else "Редактирование работника")
        self.geometry("400x300")

        # Поля ввода
        self.employee_id = ctk.CTkEntry(self, placeholder_text="Табельный №")
        self.full_name = ctk.CTkEntry(self, placeholder_text="ФИО")
        self.workshop = ctk.CTkEntry(self, placeholder_text="Цех")
        self.position = ctk.CTkEntry(self, placeholder_text="Должность")

        # Заполнение данных, если это редактирование
        if data:
            self.employee_id.insert(0, str(data[1]))  # data[1] = employee_id в таблице
            self.full_name.insert(0, data[2])
            self.workshop.insert(0, str(data[3]))
            self.position.insert(0, data[4])

        # Размещение элементов
        self.employee_id.pack(pady=5)
        self.full_name.pack(pady=5)
        self.workshop.pack(pady=5)
        self.position.pack(pady=5)

        # Кнопки
        btn_frame = ctk.CTkFrame(self)
        btn_frame.pack(pady=10)

        ctk.CTkButton(btn_frame, text="Сохранить", command=self._save).pack(side="left", padx=5)
        ctk.CTkButton(btn_frame, text="Отмена", command=self.destroy).pack(side="right", padx=5)

    def _save(self) -> None:
        """Сохранение данных работника."""
        employee_id = self.employee_id.get().strip()
        full_name = self.full_name.get().strip()
        workshop = self.workshop.get().strip()
        position = self.position.get().strip()

        # Валидация
        if not all([employee_id, full_name, workshop, position]):
            show_error("Все поля обязательны для заполнения!")
            return

        if not validate_unique_employee_id(employee_id, self.db):
            show_error("Табельный номер должен быть уникальным!")
            return

        # Сохранение в БД
        query = """
            INSERT INTO employees (employee_id, full_name, workshop_number, position)
            VALUES (?, ?, ?, ?)
            ON CONFLICT(employee_id) DO UPDATE SET
                full_name = excluded.full_name,
                workshop_number = excluded.workshop_number,
                position = excluded.position
        """
        self.db.execute_query(query, (employee_id, full_name, workshop, position))
        self.result = True
        self.destroy()
--------------------------------------------------------------------------------
Путь: gui\main_window.py
Имя файла: main_window.py
Содержимое:
# gui/main_window.py
from typing import Dict

import customtkinter as ctk

from db.database import Database
from gui.dialogs import show_error, show_info
from gui.employees_form import EmployeesForm
from gui.work_order_form import WorkOrderForm
from reports.excel_report import ExcelReportGenerator


class MainWindow(ctk.CTk):
    """Главное окно программы с вкладками для управления данными."""

    def __init__(self) -> None:
        super().__init__()
        self.title("Учет сдельных работ")
        self.geometry("1200x800")

        # Инициализация БД
        self.db: Database = Database()
        self._load_filters_data()

        # Стиль интерфейса
        ctk.set_appearance_mode("light")
        ctk.set_default_color_theme("green")

        # Создание вкладок
        self.tabview = ctk.CTkTabview(self)
        self.tabview.add("Наряды")
        self.tabview.add("Работники")
        self.tabview.add("Отчеты")
        self.tabview.pack(expand=True, fill="both", padx=20, pady=20)

        # Загрузка содержимого вкладок
        self._init_work_orders_tab()
        self._init_employees_tab()
        self._init_reports_tab()

    def _load_filters_data(self) -> None:
        """Загрузка данных для фильтров отчетов."""
        self.contracts = self.db.execute_query("SELECT contract_code FROM contracts")
        self.products = self.db.execute_query("SELECT name FROM products")

    def _init_work_orders_tab(self) -> None:
        """Инициализация вкладки 'Наряды'."""
        tab = self.tabview.tab("Наряды")
        WorkOrderForm(tab, self.db)

    def _init_employees_tab(self) -> None:
        """Инициализация вкладки 'Работники'."""
        tab = self.tabview.tab("Работники")
        EmployeesForm(tab, self.db)

    def _init_reports_tab(self) -> None:
        """Инициализация вкладки 'Отчеты'."""
        tab = self.tabview.tab("Отчеты")

        # Фрейм для фильтров
        filters_frame = ctk.CTkFrame(tab)
        filters_frame.pack(side="left", fill="y", padx=10, pady=10)

        # Поля фильтров
        ctk.CTkLabel(filters_frame, text="Фильтры отчетов", font=("Arial", 14)).pack(pady=5)

        # Дата начала
        self.start_date_entry = ctk.CTkEntry(filters_frame, placeholder_text="Дата начала (ДД.ММ.ГГГГ)")
        self.start_date_entry.pack(pady=5)

        # Дата окончания
        self.end_date_entry = ctk.CTkEntry(filters_frame, placeholder_text="Дата окончания (ДД.ММ.ГГГГ)")
        self.end_date_entry.pack(pady=5)

        # Контракты
        self.contract_combobox = ctk.CTkComboBox(
            filters_frame,
            values=[c[0] for c in self.contracts],
            placeholder_text="Выберите контракт"
        )
        self.contract_combobox.pack(pady=5)

        # Изделия
        self.product_combobox = ctk.CTkComboBox(
            filters_frame,
            values=[p[0] for p in self.products],
            placeholder_text="Выберите изделие"
        )
        self.product_combobox.pack(pady=5)

        # Фрейм для кнопок экспорта
        export_frame = ctk.CTkFrame(tab)
        export_frame.pack(side="right", fill="both", expand=True, padx=10, pady=10)

        ctk.CTkLabel(export_frame, text="Экспорт отчетов", font=("Arial", 14)).pack(pady=10)

        # Кнопки
        ctk.CTkButton(export_frame, text="Excel", command=self._export_excel).pack(pady=5, fill="x")
        ctk.CTkButton(export_frame, text="PDF", command=self._export_pdf).pack(pady=5, fill="x")
        ctk.CTkButton(export_frame, text="HTML", command=self._export_html).pack(pady=5, fill="x")

    def _get_filters(self) -> Dict:
        """Возвращает параметры фильтрации."""
        return {
            "start_date": self.start_date_entry.get(),
            "end_date": self.end_date_entry.get(),
            "contract_code": self.contract_combobox.get(),
            "product": self.product_combobox.get()
        }

    def _export_excel(self) -> None:
        """Экспорт отчета в Excel."""
        try:
            generator = ExcelReportGenerator(self.db)
            path = generator.generate(self._get_filters())
            show_info(f"Excel-отчет сохранен:\n{path}")
        except Exception as e:
            show_error(f"Ошибка: {str(e)}")

    def _export_pdf(self) -> None:
        """Экспорт отчета в PDF."""
        try:
            from reports.pdf_report import PDFReportGenerator
            generator = PDFReportGenerator(self.db)
            path = generator.generate(self._get_filters())
            if path.startswith("Ошибка"):
                show_error(path)
            else:
                show_info(f"PDF-отчет сохранен:\n{path}")
        except Exception as e:
            show_error(f"Ошибка: {str(e)}")

    def _export_html(self) -> None:
        """Экспорт отчета в HTML."""
        try:
            from reports.html_report import HTMLReportGenerator
            generator = HTMLReportGenerator(self.db)
            path = generator.generate(self._get_filters())
            if path.startswith("Ошибка"):
                show_error(path)
            else:
                show_info(f"HTML-отчет сохранен:\n{path}")
        except Exception as e:
            show_error(f"Ошибка: {str(e)}")


if __name__ == "__main__":
    try:
        app = MainWindow()
        app.mainloop()
    except Exception as e:
        show_error(f"Ошибка запуска: {str(e)}")
--------------------------------------------------------------------------------
Путь: gui\work_order_form.py
Имя файла: work_order_form.py
Содержимое:
# gui/work_order_form.py
from datetime import datetime
from tkinter import ttk
from typing import List, Dict

import customtkinter as ctk

from db.database import Database
from gui.dialogs import DatePickerDialog, WorkerSelectionDialog, show_error
from utils.validators import validate_order_data


class WorkOrderForm(ctk.CTkFrame):
    """Форма для создания и редактирования нарядов работ."""

    def __init__(self, parent: ctk.CTkFrame, db: Database) -> None:
        super().__init__(parent)
        self.db = db
        self._current_workers: List[int] = []
        self._current_works: List[Dict] = []
        self._setup_ui()
        self._load_initial_data()

    def _setup_ui(self) -> None:
        """Инициализация элементов интерфейса."""
        self.pack(expand=True, fill="both", padx=20, pady=20)

        # Поля ввода
        self.order_id_label = ctk.CTkLabel(self, text="Наряд №:")
        self.order_id_label.grid(row=0, column=0, sticky="w")
        self.order_id_value = ctk.CTkLabel(self, text="Автоматически")
        self.order_id_value.grid(row=0, column=1, sticky="w")

        # Дата наряда
        self.date_label = ctk.CTkLabel(self, text="Дата:")
        self.date_label.grid(row=1, column=0, sticky="w")
        self.date_entry = ctk.CTkEntry(self)
        self.date_entry.insert(0, datetime.now().strftime("%d.%m.%Y"))
        self.date_entry.grid(row=1, column=1, sticky="ew")
        self.date_picker_btn = ctk.CTkButton(self, text="📅", width=30, command=self._open_date_picker)
        self.date_picker_btn.grid(row=1, column=2, padx=5)

        # Выбор рабочих
        self.workers_btn = ctk.CTkButton(self, text="Выбрать рабочих", command=self._select_workers)
        self.workers_btn.grid(row=2, column=0, columnspan=3, pady=10, sticky="ew")

        # Таблица видов работ
        self.works_table = ttk.Treeview(self, columns=("work_type", "quantity", "amount"), show="headings")
        self.works_table.heading("work_type", text="Вид работы")
        self.works_table.heading("quantity", text="Количество")
        self.works_table.heading("amount", text="Сумма")
        self.works_table.grid(row=3, column=0, columnspan=3, sticky="nsew")

        # Кнопки добавления/удаления работ
        self.add_work_btn = ctk.CTkButton(self, text="+ Добавить работу", command=self._add_work)
        self.add_work_btn.grid(row=4, column=0, pady=10)
        self.remove_work_btn = ctk.CTkButton(self, text="- Удалить работу", command=self._remove_work)
        self.remove_work_btn.grid(row=4, column=1, pady=10)

        # Итоговая сумма
        self.total_label = ctk.CTkLabel(self, text="Итого:")
        self.total_label.grid(row=5, column=0, sticky="w")
        self.total_value = ctk.CTkLabel(self, text="0.00 ₽")
        self.total_value.grid(row=5, column=1, sticky="w")

        # Кнопка сохранения
        self.save_btn = ctk.CTkButton(self, text="Сохранить наряд", command=self._save_order)
        self.save_btn.grid(row=6, column=0, columnspan=3, pady=20, sticky="ew")

    def _load_initial_data(self) -> None:
        """Загрузка данных для выпадающих списков."""
        self.products = self.db.execute_query("SELECT id, name FROM products")
        self.contracts = self.db.execute_query("SELECT id, contract_code FROM contracts")

    def _open_date_picker(self) -> None:
        """Открытие диалога выбора даты."""
        dialog = DatePickerDialog(self)
        date = dialog.get_date()
        if date:
            self.date_entry.delete(0, "end")
            self.date_entry.insert(0, date.strftime("%d.%m.%Y"))

    def _select_workers(self) -> None:
        """Выбор рабочих из списка."""
        dialog = WorkerSelectionDialog(self, self.db)
        workers = dialog.get_selected_workers()
        if workers:
            self._current_workers = workers
            self.workers_btn.configure(text=f"Выбрано: {len(workers)} рабочих")

    def _add_work(self) -> None:
        """Добавление вида работы в таблицу."""
        # Заглушка: здесь будет диалог выбора работы
        work_type = ("Монтаж проводки", 150.0)  # Пример данных
        self._current_works.append({"type_id": 1, "quantity": 5, "price": work_type[1]})
        self._update_works_table()

    def _update_works_table(self) -> None:
        """Обновление таблицы работ."""
        for row in self.works_table.get_children():
            self.works_table.delete(row)

        total = 0.0
        for work in self._current_works:
            amount = work["quantity"] * work["price"]
            self.works_table.insert("", "end", values=(work["type_id"], work["quantity"], f"{amount:.2f} ₽"))
            total += amount

        self.total_value.configure(text=f"{total:.2f} ₽")

    def _save_order(self) -> None:
        is_valid, error_msg = validate_order_data(
            self.date_entry.get(),
            self._current_workers,
            self._current_works,
            self.db
        )

        if not is_valid:
            show_error(error_msg)
            return

# Пример использования диалоговых окон и валидации
--------------------------------------------------------------------------------
Путь: reports\excel_report.py
Имя файла: excel_report.py
Содержимое:
# reports/excel_report.py
import pandas as pd
from pathlib import Path
from datetime import datetime
from db.database import Database
from db.queries import REPORT_BASE_QUERY
from typing import Optional, Dict
import logging

logger = logging.getLogger(__name__)


class ExcelReportGenerator:
    """Генератор отчетов в формате Excel."""

    def __init__(self, db: Database) -> None:
        self.db = db
        self._output_dir = Path("reports/excel")
        self._output_dir.mkdir(exist_ok=True, parents=True)

    def generate(
            self,
            filters: Optional[Dict] = None,
            filename: Optional[str] = None
    ) -> Optional[str]:
        """Генерирует отчет с фильтрацией данных."""
        try:
            # Выполнение запроса
            data = self.db.execute_query(REPORT_BASE_QUERY)
            if not data:
                logger.warning("Нет данных для отчета")
                return None

            # Создание DataFrame
            df = pd.DataFrame(
                data,
                columns=["order_id", "order_date", "product", "contract_code",
                         "total_amount", "workers"]
            )

            # Применение фильтров
            if filters:
                df = self._apply_filters(df, filters)

            # Генерация имени файла
            output_path = self._get_output_path(filename)
            df.to_excel(output_path, index=False)
            return str(output_path)

        except Exception as e:
            logger.error(f"Ошибка генерации Excel-отчета: {str(e)}")
            return None

    def _apply_filters(self, df: pd.DataFrame, filters: Dict) -> pd.DataFrame:
        """Применяет фильтры к данным."""
        # Реализация фильтрации...
        return df

    def _get_output_path(self, filename: Optional[str]) -> Path:
        """Генерирует путь к файлу."""
        if filename:
            return self._output_dir / filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        return self._output_dir / f"report_{timestamp}.xlsx"
--------------------------------------------------------------------------------
Путь: reports\html_report.py
Имя файла: html_report.py
Содержимое:
# reports/html_report.py
from pathlib import Path
from datetime import datetime
from db.database import Database
from db.queries import WORK_ORDERS_FOR_PDF_HTML
from typing import Optional, Dict
import logging

logger = logging.getLogger(__name__)


class HTMLReportGenerator:
    """Генератор отчетов в формате HTML."""

    def __init__(self, db: Database) -> None:
        self.db = db
        self._output_dir = Path("reports/html")
        self._output_dir.mkdir(exist_ok=True, parents=True)

    def generate(self, filters: Optional[Dict] = None, filename: Optional[str] = None) -> Optional[str]:
        """Генерирует HTML-отчет."""
        try:
            data = self.db.execute_query(WORK_ORDERS_FOR_PDF_HTML)
            if not data:
                logger.warning("Нет данных для отчета")
                return None

            # Формирование HTML-контента
            html_content = self._build_html(data)

            # Сохранение файла
            output_path = self._get_output_path(filename)
            with open(output_path, "w", encoding="utf-8") as f:
                f.write(html_content)

            return str(output_path)

        except Exception as e:
            logger.error(f"Ошибка генерации HTML-отчета: {str(e)}")
            return None

    def _build_html(self, data: list) -> str:
        """Создает HTML-структуру."""
        # Реализация построения HTML...
        return "<html>...</html>"

    def _get_output_path(self, filename: Optional[str]) -> Path:
        """Генерирует путь к файлу."""
        if filename:
            return self._output_dir / filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        return self._output_dir / f"report_{timestamp}.html"
--------------------------------------------------------------------------------
Путь: reports\pdf_report.py
Имя файла: pdf_report.py
Содержимое:
# reports/pdf_report.py
import logging
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict

from db.database import Database
from db.queries import WORK_ORDERS_FOR_PDF_HTML

logger = logging.getLogger(__name__)


class PDFReportGenerator:
    """Генератор отчетов в формате PDF."""

    def __init__(self, db: Database) -> None:
        self.db = db
        self._output_dir = Path("reports/pdf")
        self._output_dir.mkdir(exist_ok=True, parents=True)

    def generate(self, filters: Optional[Dict] = None, filename: Optional[str] = None) -> Optional[str]:
        """Генерирует PDF-отчет."""
        try:
            data = self.db.execute_query(WORK_ORDERS_FOR_PDF_HTML)
            if not data:
                logger.warning("Нет данных для отчета")
                return None

            # Создание PDF
            output_path = self._get_output_path(filename)
            self._create_pdf(data, output_path)
            return str(output_path)

        except Exception as e:
            logger.error(f"Ошибка генерации PDF-отчета: {str(e)}")
            return None

    def _create_pdf(self, data: list, output_path: Path) -> None:
        """Создает PDF-документ."""
        # Реализация создания PDF...
        pass

    def _get_output_path(self, filename: Optional[str]) -> Path:
        """Генерирует путь к файлу."""
        if filename:
            return self._output_dir / filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        return self._output_dir / f"report_{timestamp}.pdf"
--------------------------------------------------------------------------------
Путь: tests\test_database.py
Имя файла: test_database.py
Содержимое:
import sqlite3

import pytest
from pathlib import Path
from db.database import Database
from db.backup import BackupManager

TEST_DB_PATH = "test_work_orders.db"


@pytest.fixture(scope="function")
def test_db():
    """Фикстура для создания и удаления тестовой БД."""
    db_path = Path(TEST_DB_PATH)

    # Удаление старой БД
    if db_path.exists():
        db_path.unlink(missing_ok=True)

    # Создание новой БД
    db = Database()
    db.db_path = TEST_DB_PATH
    db._init_db()  # Создает файл через Path.touch()

    # Явное создание таблиц и данных
    with db.conn:
        cursor = db.conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS employees (
                id INTEGER PRIMARY KEY,
                employee_id TEXT UNIQUE NOT NULL,
                full_name TEXT NOT NULL,
                workshop_number INTEGER NOT NULL,
                position TEXT NOT NULL
            )
        """)
        cursor.execute(
            "INSERT INTO employees (employee_id, full_name, workshop_number, position) VALUES (?, ?, ?, ?)",
            ("dummy", "Тест", 0, "Тест")
        )
        db.conn.commit()

    # Закрываем соединение, чтобы файл разблокировался
    db.conn.close()

    yield db

    # Удаление БД
    if db_path.exists():
        db_path.unlink()


def test_create_tables(test_db):
    """Проверка создания таблиц."""
    # Переоткрываем соединение для теста
    test_db.conn = sqlite3.connect(TEST_DB_PATH)
    test_db.execute_query("DELETE FROM employees")

    test_db.execute_query(
        "INSERT INTO employees (employee_id, full_name, workshop_number, position) VALUES (?, ?, ?, ?)",
        ("001", "Иванов Иван", 1, "Инженер")
    )
    result = test_db.execute_query("SELECT * FROM employees")
    assert len(result) == 1, "Данные не добавлены в таблицу."
    test_db.conn.close()


def test_backup_manager(test_db):
    """Проверка создания резервных копий."""
    # Проверка существования файла БД
    assert Path(TEST_DB_PATH).exists(), "Файл БД не создан!"

    # Создание BackupManager
    manager = BackupManager(TEST_DB_PATH, backup_dir="test_backups", max_backups=2)
    backup_path = manager.create_backup()

    # Проверки
    assert backup_path is not None, "Резервная копия не создана."
    assert Path(backup_path).exists(), "Файл резервной копии отсутствует."

    # Очистка
    for file in Path("test_backups").glob("*.db"):
        file.unlink()
    Path("test_backups").rmdir()
--------------------------------------------------------------------------------
Путь: utils\validators.py
Имя файла: validators.py
Содержимое:
# utils/validators.py
from datetime import datetime
from db.database import Database
from typing import Optional


def validate_date(date_str: str) -> bool:
    """Проверяет корректность даты в формате DD.MM.YYYY."""
    try:
        datetime.strptime(date_str, "%d.%m.%Y")
        return True
    except ValueError:
        return False


def validate_positive_integer(value: str) -> bool:
    """Проверяет, что значение является положительным целым числом."""
    try:
        number = int(value)
        return number > 0
    except ValueError:
        return False


def validate_unique_contract_code(code: str, db: Database) -> bool:
    """Проверяет уникальность шифра контракта."""
    result = db.execute_query(
        "SELECT COUNT(*) FROM contracts WHERE contract_code = ?", (code,)
    )
    return result[0][0] == 0 if result else False


def validate_unique_work_type_name(name: str, db: Database) -> bool:
    """Проверяет уникальность наименования вида работ."""
    result = db.execute_query(
        "SELECT COUNT(*) FROM work_types WHERE name = ?", (name,)
    )
    return result[0][0] == 0 if result else False


def validate_order_data(
        date: str, workers: list, works: list, db: Database
) -> tuple[bool, Optional[str]]:
    """Комплексная проверка данных наряда. Возвращает (успех, сообщение об ошибке)."""
    errors = []

    if not validate_date(date):
        errors.append("Неверный формат даты. Используйте ДД.ММ.ГГГГ")

    if not workers:
        errors.append("Выберите хотя бы одного рабочего")

    for work in works:
        if not validate_positive_integer(str(work["quantity"])):
            errors.append("Количество работ должно быть положительным числом")

    if errors:
        return (False, "\n".join(errors))
    return (True, None)


def validate_unique_employee_id(employee_id: str, db: Database) -> bool:
    """Проверяет уникальность табельного номера."""
    result = db.execute_query(
        "SELECT COUNT(*) FROM employees WHERE employee_id = ?", (employee_id,)
    )
    return result[0][0] == 0 if result else False

--------------------------------------------------------------------------------
