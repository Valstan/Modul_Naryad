Карта проекта:
conftest.py
main.py
print_proekt.py
db\backup.py
db\database.py
db\queries.py
gui\base_form.py
gui\dialogs.py
gui\employees_form.py
gui\main_window.py
gui\work_order_form.py
gui\work_types_form.py
reports\excel_report.py
reports\html_report.py
reports\pdf_report.py
tests\test_database.py
utils\excel_handler.py
utils\validators.py

--------------------------------------------------------------------------------

Путь: conftest.py
Имя файла: conftest.py
Содержимое:
# conftest.py (в корне проекта)
import sys
from pathlib import Path

# Добавляем корневую директорию в путь поиска модулей
root_dir = Path(__file__).parent
sys.path.append(str(root_dir))
--------------------------------------------------------------------------------
Путь: main.py
Имя файла: main.py
Содержимое:
# main.py
import sys
from db.backup import BackupManager
from gui.dialogs import show_error
from gui.main_window import MainWindow

def main() -> None:
    """Точка входа в программу."""
    try:
        # Создать резервную копию БД при запуске
        BackupManager("work_orders.db").create_backup()

        # Инициализация GUI
        app = MainWindow()
        app.mainloop()

    except Exception as e:
        show_error(f"Критическая ошибка: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------
Путь: print_proekt.py
Имя файла: print_proekt.py
Содержимое:
import os

def create_project_map(project_root):
    project_map = []
    for root, dirs, files in os.walk(project_root):
        if '.venv' in dirs:
            dirs.remove('.venv')  # Исключаем папку .venv из сканирования
        for file in files:
            if file.endswith('.py'):
                file_path = os.path.join(root, file)
                project_map.append(os.path.relpath(file_path, project_root))
    return project_map

project_root = os.getcwd()  # Корневая директория проекта
output_file = os.path.join(project_root, "project_contents.txt")

# Создаем карту проекта
project_map = create_project_map(project_root)

with open(output_file, 'w', encoding='utf-8') as f:
    # Записываем карту проекта
    f.write("Карта проекта:\n")
    for file_path in project_map:
        f.write(f"{file_path}\n")
    f.write('\n' + '-' * 80 + '\n\n')

    # Записываем содержимое файлов
    for file_path in project_map:
        full_path = os.path.join(project_root, file_path)
        with open(full_path, 'r', encoding='utf-8') as src_file:
            content = src_file.read()

        f.write(f"Путь: {file_path}\n")
        f.write(f"Имя файла: {os.path.basename(file_path)}\n")
        f.write("Содержимое:\n")
        f.write(content)
        f.write('\n' + '-' * 80 + '\n')

print(f"Информация о проекте сохранена в файл: {output_file}")
--------------------------------------------------------------------------------
Путь: db\backup.py
Имя файла: backup.py
Содержимое:
# db/backup.py
import os
import shutil
from pathlib import Path
from datetime import datetime
from typing import Optional


class BackupManager:
    """Управление резервными копиями БД с проверкой существования файла."""

    def __init__(self, db_path: str, backup_dir: str = "backups", max_backups: int = 20):
        self.db_path = Path(db_path)
        self.backup_dir = Path(backup_dir)
        self.max_backups = max_backups

        if not self.db_path.exists():
            raise FileNotFoundError(f"Файл БД {db_path} не найден!")

        self._ensure_backup_dir()

    def _ensure_backup_dir(self) -> None:
        """Создать директорию для резервных копий."""
        self.backup_dir.mkdir(exist_ok=True, parents=True)

    def create_backup(self) -> Optional[str]:
        """Создание резервной копии с обработкой ошибок."""
        try:
            # Генерация имени файла
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_path = self.backup_dir / f"backup_{timestamp}.db"

            # Копирование файла
            shutil.copy2(str(self.db_path), str(backup_path))
            self._cleanup_old_backups()
            return str(backup_path)

        except Exception as e:
            print(f"Ошибка резервного копирования: {str(e)}")
            return None

    def _cleanup_old_backups(self) -> None:
        """Удаление старых копий, если превышен лимит."""
        backups = sorted(
            self.backup_dir.glob("backup_*.db"),
            key=lambda x: x.stat().st_mtime,
            reverse=False
        )

        while len(backups) > self.max_backups:
            old_backup = backups.pop(0)
            os.remove(str(old_backup))
--------------------------------------------------------------------------------
Путь: db\database.py
Имя файла: database.py
Содержимое:
# db/database.py
import logging
import sqlite3
from pathlib import Path
from typing import Optional, List, Tuple, Any

logger = logging.getLogger(__name__)


class Database:
    """Singleton для управления подключением к SQLite."""
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._init_db()
        return cls._instance

    def _init_db(self) -> None:
        """Инициализация БД с автоматическим созданием файла и таблиц."""
        self.db_path = Path("work_orders.db")
        self.conn = sqlite3.connect(str(self.db_path))
        self.conn.execute("PRAGMA foreign_keys = ON")
        self._create_tables()

    def _create_tables(self) -> None:
        """Создание таблиц при первом запуске."""
        tables = [
            """CREATE TABLE IF NOT EXISTS employees (
                id INTEGER PRIMARY KEY,
                employee_id TEXT UNIQUE NOT NULL,
                full_name TEXT NOT NULL,
                workshop_number INTEGER NOT NULL,
                position TEXT NOT NULL
            )""",

            """CREATE TABLE IF NOT EXISTS work_types (
                id INTEGER PRIMARY KEY,
                name TEXT UNIQUE NOT NULL,
                unit TEXT NOT NULL,
                price REAL NOT NULL CHECK(price > 0)
            )""",

            """CREATE TABLE IF NOT EXISTS products (
                id INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                product_code TEXT UNIQUE NOT NULL
            )""",

            """CREATE TABLE IF NOT EXISTS contracts (
                id INTEGER PRIMARY KEY,
                contract_code TEXT UNIQUE NOT NULL,
                start_date TEXT NOT NULL,
                end_date TEXT NOT NULL,
                description TEXT
            )""",

            """CREATE TABLE IF NOT EXISTS work_orders (
                id INTEGER PRIMARY KEY,
                order_date TEXT NOT NULL,
                product_id INTEGER NOT NULL,
                contract_id INTEGER NOT NULL,
                total_amount REAL NOT NULL,
                FOREIGN KEY(product_id) REFERENCES products(id),
                FOREIGN KEY(contract_id) REFERENCES contracts(id)
            )""",

            """CREATE TABLE IF NOT EXISTS order_workers (
                order_id INTEGER NOT NULL,
                worker_id INTEGER NOT NULL,
                PRIMARY KEY(order_id, worker_id),
                FOREIGN KEY(order_id) REFERENCES work_orders(id),
                FOREIGN KEY(worker_id) REFERENCES employees(id)
            )""",

            """CREATE TABLE IF NOT EXISTS order_work_types (
                order_id INTEGER NOT NULL,
                work_type_id INTEGER NOT NULL,
                quantity INTEGER NOT NULL CHECK(quantity > 0),
                amount REAL NOT NULL,
                PRIMARY KEY(order_id, work_type_id),
                FOREIGN KEY(order_id) REFERENCES work_orders(id),
                FOREIGN KEY(work_type_id) REFERENCES work_types(id)
            )"""
        ]

        cursor = self.conn.cursor()
        try:
            for table in tables:
                cursor.execute(table)
            self.conn.commit()
        except sqlite3.Error as e:
            logger.error(f"Ошибка создания таблиц: {str(e)}")
            self.conn.rollback()
        finally:
            cursor.close()

    def execute_query(
            self,
            query: str,
            params: Optional[Tuple[Any, ...]] = None
    ) -> Optional[List[Tuple[Any, ...]]]:
        """Безопасное выполнение SQL-запроса с поддержкой транзакций."""
        cursor = self.conn.cursor()
        try:
            cursor.execute("BEGIN TRANSACTION")
            if params:
                cursor.execute(query, params)
            else:
                cursor.execute(query)
            result = cursor.fetchall()
            self.conn.commit()
            return result
        except sqlite3.Error as e:
            self.conn.rollback()
            logger.error(f"Ошибка выполнения запроса: {str(e)}")
            return None
        finally:
            cursor.close()

    def __del__(self) -> None:
        """Закрытие соединения при удалении объекта."""
        if hasattr(self, "conn"):
            self.conn.close()

    # Добавление индексов
    def _create_indexes(self):
        """Создание индексов для оптимизации запросов"""
        indexes = [
            "CREATE INDEX IF NOT EXISTS idx_orders_date ON work_orders(order_date)",
            "CREATE INDEX IF NOT EXISTS idx_workers_name ON employees(full_name)",
            "CREATE INDEX IF NOT EXISTS idx_contracts_code ON contracts(contract_code)"
        ]

        cursor = self.conn.cursor()
        try:
            for index in indexes:
                cursor.execute(index)
            self.conn.commit()
        except sqlite3.Error as e:
            logger.error(f"Ошибка создания индексов: {str(e)}")
--------------------------------------------------------------------------------
Путь: db\queries.py
Имя файла: queries.py
Содержимое:
# db/queries.py
REPORT_BASE_QUERY = """
SELECT
    wo.id AS order_id,
    wo.order_date,
    p.name AS product,
    c.contract_code,
    SUM(owt.amount) AS total_amount,
    GROUP_CONCAT(e.full_name, ', ') AS workers
FROM work_orders wo
LEFT JOIN products p ON wo.product_id = p.id
LEFT JOIN contracts c ON wo.contract_id = c.id
LEFT JOIN order_workers ow ON wo.id = ow.order_id
LEFT JOIN employees e ON ow.worker_id = e.id
LEFT JOIN order_work_types owt ON wo.id = owt.order_id
GROUP BY wo.id
"""

WORK_ORDERS_FOR_PDF_HTML = """
SELECT
    wo.id AS order_id,
    wo.order_date,
    p.name AS product,
    c.contract_code,
    SUM(owt.amount) AS total_amount
FROM work_orders wo
LEFT JOIN products p ON wo.product_id = p.id
LEFT JOIN contracts c ON wo.contract_id = c.id
LEFT JOIN order_work_types owt ON wo.id = owt.order_id
GROUP BY wo.id
"""
--------------------------------------------------------------------------------
Путь: gui\base_form.py
Имя файла: base_form.py
Содержимое:
# gui/base_form.py
import customtkinter as ctk
from tkinter import ttk
from typing import List, Optional, Tuple
from db.database import Database


class BaseForm(ctk.CTkFrame):
    """Базовый класс для всех форм с таблицей и кнопками управления."""

    def __init__(self, parent: ctk.CTkFrame, db: Database, columns: List[str]):
        super().__init__(parent)
        self.db = db
        self.columns = columns
        self._setup_ui()

    def _setup_ui(self) -> None:
        """Инициализация интерфейса."""
        # Таблица
        self.table = ttk.Treeview(
            self,
            columns=self.columns,
            show="headings",
            style="Custom.Treeview"
        )
        for col in self.columns:
            self.table.heading(col, text=col)
        self.table.pack(expand=True, fill="both", padx=10, pady=10)

        # Кнопки управления
        self.btn_frame = ctk.CTkFrame(self)
        self.btn_frame.pack(pady=10)

        self.add_btn = ctk.CTkButton(self.btn_frame, text="Добавить", command=self._add_item)
        self.add_btn.pack(side="left", padx=5)

        self.edit_btn = ctk.CTkButton(self.btn_frame, text="Редактировать", command=self._edit_item)
        self.edit_btn.pack(side="left", padx=5)

        self.delete_btn = ctk.CTkButton(self.btn_frame, text="Удалить", command=self._delete_item)
        self.delete_btn.pack(side="left", padx=5)

    def _load_data(self, query: str, params: Optional[Tuple] = None) -> None:
        """Загружает данные из БД в таблицу."""
        for row in self.table.get_children():
            self.table.delete(row)
        data = self.db.execute_query(query, params)
        for item in data:
            self.table.insert("", "end", values=item)

    def _add_item(self) -> None:
        """Добавление элемента (реализуется в дочерних классах)."""
        raise NotImplementedError

    def _edit_item(self) -> None:
        """Редактирование элемента (реализуется в дочерних классах)."""
        raise NotImplementedError

    def _delete_item(self) -> None:
        """Удаление элемента (реализуется в дочерних классах)."""
        raise NotImplementedError
--------------------------------------------------------------------------------
Путь: gui\dialogs.py
Имя файла: dialogs.py
Содержимое:
# gui/dialogs.py
from tkinter import ttk

import customtkinter as ctk
from tkcalendar import Calendar
from datetime import datetime
from typing import List, Optional, Tuple
from db.database import Database


class DatePickerDialog(ctk.CTkToplevel):
    """Диалоговое окно выбора даты."""

    def __init__(self, parent: ctk.CTkFrame) -> None:
        super().__init__(parent)
        self.title("Выбор даты")
        self.geometry("300x200")
        self.resizable(False, False)
        self._selected_date: Optional[datetime] = None

        # Календарь из tkcalendar
        self.calendar = Calendar(self, selectmode="day", date_pattern="dd.mm.yyyy")
        self.calendar.pack(pady=10)

        # Кнопки
        self.btn_frame = ctk.CTkFrame(self)
        self.btn_frame.pack(pady=10)

        self.ok_btn = ctk.CTkButton(self.btn_frame, text="OK", command=self._on_ok)
        self.ok_btn.pack(side="left", padx=5)

        self.cancel_btn = ctk.CTkButton(self.btn_frame, text="Отмена", command=self.destroy)
        self.cancel_btn.pack(side="right", padx=5)

    def _on_ok(self) -> None:
        """Обработка выбора даты."""
        try:
            self._selected_date = datetime.strptime(self.calendar.get_date(), "%d.%m.%Y")
            self.destroy()
        except ValueError:
            self._selected_date = None

    def get_date(self) -> Optional[datetime]:
        """Возвращает выбранную дату."""
        return self._selected_date


class WorkerSelectionDialog(ctk.CTkToplevel):
    """Диалоговое окно выбора рабочих."""

    def __init__(self, parent: ctk.CTkFrame, db: Database) -> None:
        super().__init__(parent)
        self.title("Выбор рабочих")
        self.geometry("600x400")
        self.db = db
        self._selected_ids: List[int] = []
        self._setup_ui()

    def _setup_ui(self) -> None:
        """Инициализация интерфейса."""
        # Таблица работников
        self.tree = ttk.Treeview(self, columns=("id", "name", "workshop"), show="headings")
        self.tree.heading("id", text="Табельный №")
        self.tree.heading("name", text="ФИО")
        self.tree.heading("workshop", text="Цех")
        self.tree.pack(expand=True, fill="both", padx=10, pady=10)

        # Загрузка данных
        workers = self.db.execute_query("SELECT employee_id, full_name, workshop_number FROM employees")
        for worker in workers:
            self.tree.insert("", "end", values=worker)

        # Кнопки
        self.btn_frame = ctk.CTkFrame(self)
        self.btn_frame.pack(pady=10)

        self.select_btn = ctk.CTkButton(self.btn_frame, text="Выбрать", command=self._on_select)
        self.select_btn.pack(side="left", padx=5)

        self.cancel_btn = ctk.CTkButton(self.btn_frame, text="Отмена", command=self.destroy)
        self.cancel_btn.pack(side="right", padx=5)

    def _on_select(self) -> None:
        """Обработка выбранных рабочих."""
        selected_items = self.tree.selection()
        self._selected_ids = [int(self.tree.item(item)["values"][0]) for item in selected_items]
        self.destroy()

    def get_selected_workers(self) -> List[int]:
        """Возвращает список ID выбранных рабочих."""
        return self._selected_ids


def show_error(message: str) -> None:
    """Отображает окно с сообщением об ошибке."""
    dialog = ctk.CTkToplevel()
    dialog.title("Ошибка")
    dialog.geometry("400x100")

    label = ctk.CTkLabel(dialog, text=message, text_color="red")
    label.pack(pady=20)

    btn = ctk.CTkButton(dialog, text="OK", command=dialog.destroy)
    btn.pack(pady=5)


def show_info(message: str) -> None:
    """Отображает информационное сообщение."""
    dialog = ctk.CTkToplevel()
    dialog.title("Информация")
    dialog.geometry("400x100")

    label = ctk.CTkLabel(dialog, text=message)
    label.pack(pady=20)

    btn = ctk.CTkButton(dialog, text="OK", command=dialog.destroy)
    btn.pack(pady=5)
--------------------------------------------------------------------------------
Путь: gui\employees_form.py
Имя файла: employees_form.py
Содержимое:
# gui/employees_form.py
from typing import Optional

import customtkinter as ctk
from db.database import Database
from gui.base_form import BaseForm
from gui.dialogs import show_error, show_info
from utils.validators import validate_unique_employee_id


class EmployeesForm(BaseForm):
    """Форма для управления данными работников."""

    def __init__(self, parent: ctk.CTkFrame, db: Database):
        columns = ["Табельный №", "ФИО", "Цех", "Должность"]
        super().__init__(parent, db, columns)
        self._load_data("SELECT employee_id, full_name, workshop_number, position FROM employees")

    def _add_item(self) -> None:
        """Открытие диалога добавления работника."""
        dialog = EmployeeDialog(self, self.db)
        if dialog.result:
            self._load_data("SELECT employee_id, full_name, workshop_number, position FROM employees")

    def _edit_item(self) -> None:
        """Открытие диалога редактирования работника."""
        selected = self.table.selection()
        if not selected:
            show_error("Выберите работника!")
            return

        employee_data = self.table.item(selected[0])["values"]
        dialog = EmployeeDialog(self, self.db, employee_data)
        if dialog.result:
            self._load_data("SELECT employee_id, full_name, workshop_number, position FROM employees")

    def _delete_item(self) -> None:
        """Удаление выбранного работника."""
        selected = self.table.selection()
        if not selected:
            show_error("Выберите работника!")
            return

        employee_id = self.table.item(selected[0])["values"][0]
        self.db.execute_query("DELETE FROM employees WHERE employee_id = ?", (employee_id,))
        self._load_data("SELECT employee_id, full_name, workshop_number, position FROM employees")


class EmployeeDialog(ctk.CTkToplevel):
    """Диалог для добавления/редактирования работника."""

    def __init__(self, parent: ctk.CTkFrame, db: Database, data: Optional[list] = None):
        super().__init__(parent)
        self.db = db
        self.result = False
        self.title("Данные работника" if not data else "Редактирование работника")
        self.geometry("400x300")

        # Поля ввода
        self.employee_id = ctk.CTkEntry(self, placeholder_text="Табельный №")
        self.full_name = ctk.CTkEntry(self, placeholder_text="ФИО")
        self.workshop = ctk.CTkEntry(self, placeholder_text="Цех")
        self.position = ctk.CTkEntry(self, placeholder_text="Должность")

        # Заполнение данных, если это редактирование
        if data:
            self.employee_id.insert(0, str(data[1]))  # data[1] = employee_id в таблице
            self.full_name.insert(0, data[2])
            self.workshop.insert(0, str(data[3]))
            self.position.insert(0, data[4])

        # Размещение элементов
        self.employee_id.pack(pady=5)
        self.full_name.pack(pady=5)
        self.workshop.pack(pady=5)
        self.position.pack(pady=5)

        # Кнопки
        btn_frame = ctk.CTkFrame(self)
        btn_frame.pack(pady=10)

        ctk.CTkButton(btn_frame, text="Сохранить", command=self._save).pack(side="left", padx=5)
        ctk.CTkButton(btn_frame, text="Отмена", command=self.destroy).pack(side="right", padx=5)

    def _save(self) -> None:
        """Сохранение данных работника."""
        employee_id = self.employee_id.get().strip()
        full_name = self.full_name.get().strip()
        workshop = self.workshop.get().strip()
        position = self.position.get().strip()

        # Валидация
        if not all([employee_id, full_name, workshop, position]):
            show_error("Все поля обязательны для заполнения!")
            return

        if not validate_unique_employee_id(employee_id, self.db):
            show_error("Табельный номер должен быть уникальным!")
            return

        # Сохранение в БД
        query = """
            INSERT INTO employees (employee_id, full_name, workshop_number, position)
            VALUES (?, ?, ?, ?)
            ON CONFLICT(employee_id) DO UPDATE SET
                full_name = excluded.full_name,
                workshop_number = excluded.workshop_number,
                position = excluded.position
        """
        self.db.execute_query(query, (employee_id, full_name, workshop, position))
        self.result = True
        self.destroy()
--------------------------------------------------------------------------------
Путь: gui\main_window.py
Имя файла: main_window.py
Содержимое:
# gui/main_window.py
import logging
from pathlib import Path
from tkinter import filedialog
from typing import Optional

import customtkinter as ctk

from db.database import Database
from gui.dialogs import show_error, show_info
from gui.employees_form import EmployeesForm
from gui.work_order_form import WorkOrderForm
from gui.work_types_form import WorkTypesForm
from reports.excel_report import ExcelReportGenerator
from utils.excel_handler import ExcelHandler

logger = logging.getLogger(__name__)


class MainWindow(ctk.CTk):
    """Главное окно программы с обработкой ошибок и проверкой данных."""

    def __init__(self) -> None:
        super().__init__()
        self.title("Учет сдельных работ")
        self.geometry("1200x800")
        self.db = Database()
        self._load_filters_data()

        # Настройка интерфейса
        ctk.set_appearance_mode("light")
        ctk.set_default_color_theme("green")
        self._init_ui()

    def _init_ui(self) -> None:
        """Инициализация пользовательского интерфейса с обработкой ошибок."""
        try:
            self.tabview = ctk.CTkTabview(self)
            self._create_tabs()
            self._init_import_export_buttons()
        except Exception as e:
            logger.error(f"Ошибка инициализации интерфейса: {str(e)}")
            show_error("Критическая ошибка при создании интерфейса")

    def _create_tabs(self) -> None:
        """Создание вкладок с обработкой исключений."""
        tabs = ["Наряды", "Работники", "Виды работ", "Отчеты"]
        for tab in tabs:
            self.tabview.add(tab)
        self.tabview.pack(expand=True, fill="both", padx=20, pady=20)

        self._init_work_orders_tab()
        self._init_employees_tab()
        self._init_work_types_tab()
        self._init_reports_tab()

    def _load_filters_data(self) -> None:
        """Загрузка данных для фильтров с проверкой на ошибки."""
        try:
            self.contracts = self._safe_query("SELECT contract_code FROM contracts") or []
            self.products = self._safe_query("SELECT name FROM products") or []
        except Exception as e:
            logger.error(f"Ошибка загрузки фильтров: {str(e)}")
            show_error("Ошибка загрузки справочников")

    def _safe_query(self, query: str) -> Optional[list]:
        """Безопасное выполнение запроса с обработкой ошибок."""
        result = self.db.execute_query(query)
        if result is None:
            logger.warning(f"Пустой результат для запроса: {query}")
        return result

    def _init_work_orders_tab(self) -> None:
        """Инициализация вкладки с нарядами."""
        try:
            tab = self.tabview.tab("Наряды")
            WorkOrderForm(tab, self.db)
        except Exception as e:
            logger.error(f"Ошибка инициализации вкладки нарядов: {str(e)}")
            show_error("Ошибка создания формы нарядов")

    def _init_employees_tab(self) -> None:
        """Инициализация вкладки с работниками."""
        try:
            tab = self.tabview.tab("Работники")
            EmployeesForm(tab, self.db)
        except Exception as e:
            logger.error(f"Ошибка инициализации вкладки работников: {str(e)}")
            show_error("Ошибка создания формы работников")

    def _init_work_types_tab(self) -> None:
        """Инициализация вкладки с видами работ."""
        try:
            tab = self.tabview.tab("Виды работ")
            WorkTypesForm(tab, self.db)
        except Exception as e:
            logger.error(f"Ошибка инициализации вкладки видов работ: {str(e)}")
            show_error("Ошибка создания формы видов работ")

    def _init_reports_tab(self) -> None:
        """Инициализация вкладки отчетов с базовой функциональностью."""
        try:
            tab = self.tabview.tab("Отчеты")
            btn_frame = ctk.CTkFrame(tab)
            btn_frame.pack(pady=20)

            ctk.CTkButton(
                btn_frame,
                text="Сформировать Excel-отчет",
                command=self._generate_excel_report
            ).pack(side="left", padx=10)

            ctk.CTkButton(
                btn_frame,
                text="Сформировать PDF-отчет",
                command=self._generate_pdf_report
            ).pack(side="left", padx=10)
        except Exception as e:
            logger.error(f"Ошибка инициализации вкладки отчетов: {str(e)}")

    def _generate_excel_report(self) -> None:
        """Генерация Excel-отчета с обработкой ошибок."""
        try:
            generator = ExcelReportGenerator(self.db)
            report_path = generator.generate()
            if report_path:
                show_info(f"Отчет сохранен: {report_path}")
        except Exception as e:
            logger.error(f"Ошибка генерации Excel-отчета: {str(e)}")
            show_error("Ошибка создания отчета")

    def _generate_pdf_report(self) -> None:
        """Заглушка для генерации PDF-отчета."""
        show_info("PDF-отчеты временно недоступны")

    def _init_import_export_buttons(self) -> None:
        """Добавление кнопок импорта/экспорта с проверкой прав доступа."""
        self._add_buttons_to_tab("Работники")
        self._add_buttons_to_tab("Виды работ")

    def _add_buttons_to_tab(self, tab_name: str) -> None:
        """Создание кнопок для операций с Excel."""
        try:
            tab = self.tabview.tab(tab_name)
            btn_frame = ctk.CTkFrame(tab)
            btn_frame.pack(pady=10)

            ctk.CTkButton(
                btn_frame,
                text="Экспорт в Excel",
                command=lambda: self._export_data(tab_name)
            ).pack(side="left", padx=5)

            ctk.CTkButton(
                btn_frame,
                text="Импорт из Excel",
                command=lambda: self._import_data(tab_name)
            ).pack(side="right", padx=5)
        except Exception as e:
            logger.error(f"Ошибка создания кнопок для {tab_name}: {str(e)}")

    def _export_data(self, table_name: str) -> None:
        """Экспорт данных с обработкой исключений."""
        try:
            file_path = filedialog.asksaveasfilename(
                defaultextension=".xlsx",
                filetypes=[("Excel Files", "*.xlsx")]
            )
            if not file_path:
                return

            handler = ExcelHandler(self.db)
            if handler.export_table(table_name.lower(), Path(file_path)):
                show_info("Данные успешно экспортированы")
            else:
                show_error("Ошибка при экспорте")
        except Exception as e:
            logger.error(f"Ошибка экспорта данных: {str(e)}")
            show_error("Ошибка при экспорте данных")

    def _import_data(self, table_name: str) -> None:
        """Импорт данных с проверкой формата файла."""
        try:
            file_path = filedialog.askopenfilename(
                filetypes=[("Excel Files", "*.xlsx")]
            )
            if not file_path:
                return

            handler = ExcelHandler(self.db)
            success, msg = handler.import_table(table_name.lower(), Path(file_path))
            if success:
                show_info(msg)
                self._reload_current_tab()
            else:
                show_error(msg)
        except Exception as e:
            logger.error(f"Ошибка импорта данных: {str(e)}")
            show_error("Ошибка при импорте данных")

    def _reload_current_tab(self) -> None:
        """Перезагрузка текущей вкладки с обновлением данных."""
        current_tab = self.tabview.get()
        try:
            if current_tab == "Работники":
                self._init_employees_tab()
            elif current_tab == "Виды работ":
                self._init_work_types_tab()
        except Exception as e:
            logger.error(f"Ошибка перезагрузки вкладки: {str(e)}")


if __name__ == "__main__":
    app = MainWindow()
    app.mainloop()
--------------------------------------------------------------------------------
Путь: gui\work_order_form.py
Имя файла: work_order_form.py
Содержимое:
# gui/work_order_form.py
import logging
from datetime import datetime
from typing import List, Dict, Optional, Tuple

import customtkinter as ctk
from tkinter import ttk

from db.database import Database
from gui.dialogs import DatePickerDialog, WorkerSelectionDialog, show_error, show_info
from utils.validators import validate_date, validate_positive_number

logger = logging.getLogger(__name__)


class WorkOrderForm(ctk.CTkFrame):
    """Форма для создания и редактирования нарядов работ с полной валидацией."""

    def __init__(self, parent: ctk.CTkFrame, db: Database) -> None:
        super().__init__(parent)
        self.db = db
        self._current_workers: List[int] = []
        self._current_works: List[Dict] = []
        self._setup_ui()
        self._load_initial_data()

    def _setup_ui(self) -> None:
        """Инициализация элементов интерфейса с улучшенной компоновкой."""
        self.grid_columnconfigure(1, weight=1)
        self.grid_rowconfigure(3, weight=1)

        # Заголовок формы
        ctk.CTkLabel(self, text="Новый наряд работ", font=("Arial", 14, "bold")).grid(
            row=0, column=0, columnspan=3, pady=10, sticky="w"
        )

        # Поля ввода
        self._create_input_fields()
        self._create_workers_section()
        self._create_works_table()
        self._create_total_section()
        self._create_control_buttons()

    def _create_input_fields(self) -> None:
        """Создание полей для основных данных наряда."""
        # Дата наряда
        ctk.CTkLabel(self, text="Дата:").grid(row=1, column=0, sticky="e", padx=5)
        self.date_entry = ctk.CTkEntry(self)
        self.date_entry.insert(0, datetime.now().strftime("%d.%m.%Y"))
        self.date_entry.grid(row=1, column=1, sticky="ew", padx=5)

        ctk.CTkButton(
            self,
            text="📅",
            width=30,
            command=self._open_date_picker
        ).grid(row=1, column=2, padx=5)

        # Выбор изделия и контракта
        self._create_combobox("Изделие:", "products", row=2)
        self._create_combobox("Контракт:", "contracts", row=3)

    def _create_combobox(self, label: str, table: str, row: int) -> None:
        """Создание выпадающего списка для связанных сущностей."""
        ctk.CTkLabel(self, text=label).grid(row=row, column=0, sticky="e", padx=5)
        values = self._get_combobox_values(table)
        combobox = ctk.CTkComboBox(self, values=values)
        combobox.grid(row=row, column=1, sticky="ew", padx=5, pady=2)
        setattr(self, f"{table}_combobox", combobox)

    def _get_combobox_values(self, table: str) -> List[str]:
        """Загрузка данных для выпадающих списков."""
        try:
            if table == "products":
                result = self.db.execute_query("SELECT id, name FROM products")
            elif table == "contracts":
                result = self.db.execute_query("SELECT id, contract_code FROM contracts")
            return [f"{row[0]} - {row[1]}" for row in result] if result else []
        except Exception as e:
            logger.error(f"Ошибка загрузки {table}: {str(e)}")
            return []

    def _load_initial_data(self) -> None:
        """Инициализация данных для выпадающих списков."""
        try:
            products = self.db.execute_query("SELECT id, name FROM products")
            contracts = self.db.execute_query("SELECT id, contract_code FROM contracts")

            self.products_combobox.configure(
                values=[f"{p[0]} - {p[1]}" for p in products] if products else []
            )
            self.contracts_combobox.configure(
                values=[f"{c[0]} - {c[1]}" for c in contracts] if contracts else []
            )
        except Exception as e:
            logger.error(f"Ошибка загрузки данных: {str(e)}")
            show_error("Ошибка загрузки справочников")

    def _create_workers_section(self) -> None:
        """Секция выбора рабочих бригады."""
        self.workers_btn = ctk.CTkButton(
            self,
            text="Выбрать рабочих (0)",
            command=self._select_workers
        )
        self.workers_btn.grid(row=4, column=0, columnspan=3, pady=10, sticky="ew")

    def _create_works_table(self) -> None:
        """Таблица видов работ с улучшенным стилем."""
        columns = ("Вид работы", "Количество", "Цена", "Сумма")
        self.works_table = ttk.Treeview(
            self,
            columns=columns,
            show="headings",
            style="Custom.Treeview",
            height=6
        )

        for col in columns:
            self.works_table.heading(col, text=col)
            self.works_table.column(col, width=120, anchor="center")

        self.works_table.grid(row=5, column=0, columnspan=3, sticky="nsew", pady=10)

    def _create_total_section(self) -> None:
        """Секция отображения итоговой суммы."""
        ctk.CTkLabel(self, text="Итого:").grid(row=6, column=0, sticky="e", padx=5)
        self.total_value = ctk.CTkLabel(self, text="0.00 ₽")
        self.total_value.grid(row=6, column=1, sticky="w", padx=5)

    def _create_control_buttons(self) -> None:
        """Кнопки управления нарядом."""
        btn_frame = ctk.CTkFrame(self)
        btn_frame.grid(row=7, column=0, columnspan=3, pady=10)

        ctk.CTkButton(
            btn_frame,
            text="Добавить работу",
            command=self._add_work
        ).pack(side="left", padx=5)

        ctk.CTkButton(
            btn_frame,
            text="Удалить работу",
            command=self._remove_work
        ).pack(side="left", padx=5)

        ctk.CTkButton(
            btn_frame,
            text="Сохранить наряд",
            command=self._save_order
        ).pack(side="right", padx=5)

    def _open_date_picker(self) -> None:
        """Обработчик выбора даты с валидацией."""
        dialog = DatePickerDialog(self)
        date = dialog.get_date()
        if date:
            self.date_entry.delete(0, "end")
            self.date_entry.insert(0, date.strftime("%d.%m.%Y"))

    def _select_workers(self) -> None:
        """Выбор рабочих с обновлением счетчика."""
        dialog = WorkerSelectionDialog(self, self.db)
        workers = dialog.get_selected_workers()
        if workers:
            self._current_workers = workers
            self.workers_btn.configure(text=f"Выбрано: {len(workers)} рабочих")

    def _add_work(self) -> None:
        """Добавление вида работы через диалоговое окно."""
        try:
            work_types = self.db.execute_query(
                "SELECT id, name, price FROM work_types"
            )
            if not work_types:
                show_error("Нет доступных видов работ")
                return

            dialog = WorkTypeSelectionDialog(self, work_types)
            selected = dialog.get_selected_work()
            if selected:
                self._current_works.append({
                    "type_id": selected[0],
                    "name": selected[1],
                    "price": selected[2],
                    "quantity": selected[3]
                })
                self._update_works_table()
        except Exception as e:
            logger.error(f"Ошибка добавления работы: {str(e)}")
            show_error("Ошибка при выборе вида работ")

    def _update_works_table(self) -> None:
        """Обновление таблицы с пересчетом сумм."""
        for row in self.works_table.get_children():
            self.works_table.delete(row)

        total = 0.0
        for work in self._current_works:
            amount = work["price"] * work["quantity"]
            self.works_table.insert("", "end", values=(
                work["name"],
                work["quantity"],
                f"{work['price']:.2f} ₽",
                f"{amount:.2f} ₽"
            ))
            total += amount

        self.total_value.configure(text=f"{total:.2f} ₽")

    def _remove_work(self) -> None:
        """Удаление выбранной работы из таблицы."""
        selected = self.works_table.selection()
        if not selected:
            show_error("Выберите работу для удаления")
            return

        index = self.works_table.index(selected[0])
        del self._current_works[index]
        self._update_works_table()

    def _save_order(self) -> None:
        """Сохранение наряда с полной валидацией."""
        try:
            # Валидация основных полей
            errors = self._validate_basic_fields()
            if errors:
                show_error("\n".join(errors))
                return

            # Валидация связанных данных
            product_id = self._get_selected_id("products")
            contract_id = self._get_selected_id("contracts")
            if not product_id or not contract_id:
                show_error("Не выбрано изделие или контракт")
                return

            # Сохранение в БД
            order_id = self._save_to_database(product_id, contract_id)
            self._save_related_data(order_id)

            show_info("Наряд успешно сохранен")
            self._clear_form()
        except Exception as e:
            logger.error(f"Ошибка сохранения наряда: {str(e)}")
            show_error("Ошибка сохранения данных")

    def _validate_basic_fields(self) -> List[str]:
        """Валидация обязательных полей формы."""
        errors = []
        if not validate_date(self.date_entry.get()):
            errors.append("Неверный формат даты (дд.мм.гггг)")
        if not self._current_workers:
            errors.append("Выберите минимум одного рабочего")
        if not self._current_works:
            errors.append("Добавьте минимум один вид работ")
        return errors

    def _get_selected_id(self, field: str) -> Optional[int]:
        """Получение ID выбранного элемента из комбобокса."""
        value = getattr(self, f"{field}_combobox").get()
        return int(value.split(" - ")[0]) if value else None

    def _save_to_database(self, product_id: int, contract_id: int) -> int:
        """Сохранение основного наряда в БД."""
        total = sum(work["price"] * work["quantity"] for work in self._current_works)

        result = self.db.execute_query(
            """INSERT INTO work_orders 
               (order_date, product_id, contract_id, total_amount)
               VALUES (?, ?, ?, ?)
               RETURNING id""",
            (self.date_entry.get(), product_id, contract_id, total)
        )

        if not result:
            raise ValueError("Ошибка сохранения наряда")
        return result[0][0]

    def _save_related_data(self, order_id: int) -> None:
        """Сохранение связанных данных (работники и виды работ)."""
        # Сохранение рабочих
        workers_data = [(order_id, worker_id) for worker_id in self._current_workers]
        self.db.execute_query(
            "INSERT INTO order_workers (order_id, worker_id) VALUES (?, ?)",
            workers_data,
            many=True
        )

        # Сохранение видов работ
        works_data = [
            (order_id, work["type_id"], work["quantity"], work["price"] * work["quantity"])
            for work in self._current_works
        ]
        self.db.execute_query(
            """INSERT INTO order_work_types 
               (order_id, work_type_id, quantity, amount)
               VALUES (?, ?, ?, ?)""",
            works_data,
            many=True
        )

    def _clear_form(self) -> None:
        """Очистка формы после успешного сохранения."""
        self.date_entry.delete(0, "end")
        self.date_entry.insert(0, datetime.now().strftime("%d.%m.%Y"))
        self.products_combobox.set("")
        self.contracts_combobox.set("")
        self._current_workers = []
        self._current_works = []
        self.workers_btn.configure(text="Выбрать рабочих (0)")
        self._update_works_table()


class WorkTypeSelectionDialog(ctk.CTkToplevel):
    """Диалог выбора вида работ с возможностью указания количества."""

    def __init__(self, parent: ctk.CTkFrame, work_types: List[Tuple]):
        super().__init__(parent)
        self.title("Выбор вида работ")
        self.geometry("400x300")
        self._selected = None

        # Таблица видов работ
        self.tree = ttk.Treeview(
            self,
            columns=("Наименование", "Цена"),
            show="headings"
        )
        self.tree.heading("Наименование", text="Наименование")
        self.tree.heading("Цена", text="Цена за ед.")
        self.tree.pack(expand=True, fill="both", padx=10, pady=10)

        for wt in work_types:
            self.tree.insert("", "end", values=(wt[1], f"{wt[2]:.2f} ₽"), tags=(wt[0],))

        # Поле для количества
        self.quantity_entry = ctk.CTkEntry(self, placeholder_text="Количество")
        self.quantity_entry.pack(pady=5)

        # Кнопки
        btn_frame = ctk.CTkFrame(self)
        btn_frame.pack(pady=10)

        ctk.CTkButton(
            btn_frame,
            text="Выбрать",
            command=self._on_select
        ).pack(side="left", padx=5)

        ctk.CTkButton(
            btn_frame,
            text="Отмена",
            command=self.destroy
        ).pack(side="right", padx=5)

    def _on_select(self) -> None:
        """Обработка выбора вида работ."""
        selected = self.tree.selection()
        if not selected:
            show_error("Выберите вид работ")
            return

        try:
            quantity = int(self.quantity_entry.get())
            if quantity <= 0:
                raise ValueError
        except ValueError:
            show_error("Введите корректное количество")
            return

        self._selected = (
            int(self.tree.item(selected[0], "tags")[0]),  # ID
            self.tree.item(selected[0], "values")[0],  # Наименование
            float(self.tree.item(selected[0], "values")[1].split()[0]),  # Цена
            quantity
        )
        self.destroy()

    def get_selected_work(self) -> Optional[Tuple]:
        return self._selected
--------------------------------------------------------------------------------
Путь: gui\work_types_form.py
Имя файла: work_types_form.py
Содержимое:
# gui/work_types_form.py
from typing import Optional

import customtkinter as ctk

from db.database import Database
from gui.base_form import BaseForm
from gui.dialogs import show_error
from utils.validators import validate_unique_work_type_name


class WorkTypesForm(BaseForm):
    """Форма для управления видами работ."""

    def __init__(self, parent: ctk.CTkFrame, db: Database):
        columns = ["Наименование", "Единица измерения", "Цена (руб)"]
        super().__init__(parent, db, columns)
        self._load_data("SELECT name, unit, price FROM work_types")

    def _add_item(self) -> None:
        """Открытие диалога добавления вида работ."""
        dialog = WorkTypeDialog(self, self.db)
        if dialog.result:
            self._load_data("SELECT name, unit, price FROM work_types")

    def _edit_item(self) -> None:
        """Редактирование выбранного вида работ."""
        selected = self.table.selection()
        if not selected:
            show_error("Выберите вид работ!")
            return

        work_data = self.table.item(selected[0])["values"]
        dialog = WorkTypeDialog(self, self.db, work_data)
        if dialog.result:
            self._load_data("SELECT name, unit, price FROM work_types")

    def _delete_item(self) -> None:
        """Удаление выбранного вида работ."""
        selected = self.table.selection()
        if not selected:
            show_error("Выберите вид работ!")
            return

        work_name = self.table.item(selected[0])["values"][0]
        self.db.execute_query("DELETE FROM work_types WHERE name = ?", (work_name,))
        self._load_data("SELECT name, unit, price FROM work_types")


class WorkTypeDialog(ctk.CTkToplevel):
    """Диалог для добавления/редактирования вида работ."""

    def __init__(self, parent: ctk.CTkFrame, db: Database, data: Optional[list] = None):
        super().__init__(parent)
        self.db = db
        self.result = False
        self.title("Новый вид работ" if not data else "Редактирование")
        self.geometry("400x250")

        # Поля ввода
        self.name_entry = ctk.CTkEntry(self, placeholder_text="Наименование*")
        self.unit_combobox = ctk.CTkComboBox(self, values=["штуки", "комплекты"])
        self.price_entry = ctk.CTkEntry(self, placeholder_text="Цена*")

        # Заполнение данных
        if data:
            self.name_entry.insert(0, data[0])
            self.unit_combobox.set(data[1])
            self.price_entry.insert(0, str(data[2]))

        # Размещение элементов
        self.name_entry.pack(pady=5)
        self.unit_combobox.pack(pady=5)
        self.price_entry.pack(pady=5)

        # Кнопки
        btn_frame = ctk.CTkFrame(self)
        btn_frame.pack(pady=10)

        ctk.CTkButton(btn_frame, text="Сохранить", command=self._save).pack(side="left", padx=5)
        ctk.CTkButton(btn_frame, text="Отмена", command=self.destroy).pack(side="right", padx=5)

    def _save(self) -> None:
        """Сохранение данных."""
        name = self.name_entry.get().strip()
        unit = self.unit_combobox.get()
        price = self.price_entry.get().strip()

        # Валидация
        if not all([name, unit, price]):
            show_error("Заполните все обязательные поля!")
            return

        if not validate_unique_work_type_name(name, self.db):
            show_error("Наименование должно быть уникальным!")
            return

        try:
            price = float(price)
        except ValueError:
            show_error("Некорректное значение цены!")
            return

        # Сохранение в БД
        query = """
            INSERT INTO work_types (name, unit, price)
            VALUES (?, ?, ?)
            ON CONFLICT(name) DO UPDATE SET
                unit = excluded.unit,
                price = excluded.price
        """
        self.db.execute_query(query, (name, unit, price))
        self.result = True
        self.destroy()
--------------------------------------------------------------------------------
Путь: reports\excel_report.py
Имя файла: excel_report.py
Содержимое:
# reports/excel_report.py
import pandas as pd
from pathlib import Path
from datetime import datetime
from db.database import Database
from db.queries import REPORT_BASE_QUERY
from typing import Optional, Dict
import logging

logger = logging.getLogger(__name__)


class ExcelReportGenerator:
    """Генератор отчетов в формате Excel."""

    def __init__(self, db: Database) -> None:
        self.db = db
        self._output_dir = Path("reports/excel")
        self._output_dir.mkdir(exist_ok=True, parents=True)

    def generate(
            self,
            filters: Optional[Dict] = None,
            filename: Optional[str] = None
    ) -> Optional[str]:
        """Генерирует отчет с фильтрацией данных."""
        try:
            # Выполнение запроса
            data = self.db.execute_query(REPORT_BASE_QUERY)
            if not data:
                logger.warning("Нет данных для отчета")
                return None

            # Создание DataFrame
            df = pd.DataFrame(
                data,
                columns=["order_id", "order_date", "product", "contract_code",
                         "total_amount", "workers"]
            )

            # Применение фильтров
            if filters:
                df = self._apply_filters(df, filters)

            # Генерация имени файла
            output_path = self._get_output_path(filename)
            df.to_excel(output_path, index=False)
            return str(output_path)

        except Exception as e:
            logger.error(f"Ошибка генерации Excel-отчета: {str(e)}")
            return None

    def _apply_filters(self, df: pd.DataFrame, filters: Dict) -> pd.DataFrame:
        """Применяет фильтры к данным."""
        # Реализация фильтрации...
        return df

    def _get_output_path(self, filename: Optional[str]) -> Path:
        """Генерирует путь к файлу."""
        if filename:
            return self._output_dir / filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        return self._output_dir / f"report_{timestamp}.xlsx"
--------------------------------------------------------------------------------
Путь: reports\html_report.py
Имя файла: html_report.py
Содержимое:
# reports/html_report.py
from pathlib import Path
from datetime import datetime
from db.database import Database
from db.queries import WORK_ORDERS_FOR_PDF_HTML
from typing import Optional, Dict
import logging

logger = logging.getLogger(__name__)


class HTMLReportGenerator:
    """Генератор отчетов в формате HTML."""

    def __init__(self, db: Database) -> None:
        self.db = db
        self._output_dir = Path("reports/html")
        self._output_dir.mkdir(exist_ok=True, parents=True)

    def generate(self, filters: Optional[Dict] = None, filename: Optional[str] = None) -> Optional[str]:
        """Генерирует HTML-отчет."""
        try:
            data = self.db.execute_query(WORK_ORDERS_FOR_PDF_HTML)
            if not data:
                logger.warning("Нет данных для отчета")
                return None

            # Формирование HTML-контента
            html_content = self._build_html(data)

            # Сохранение файла
            output_path = self._get_output_path(filename)
            with open(output_path, "w", encoding="utf-8") as f:
                f.write(html_content)

            return str(output_path)

        except Exception as e:
            logger.error(f"Ошибка генерации HTML-отчета: {str(e)}")
            return None

    def _build_html(self, data: list) -> str:
        """Создает HTML-структуру."""
        # Реализация построения HTML...
        return "<html>...</html>"

    def _get_output_path(self, filename: Optional[str]) -> Path:
        """Генерирует путь к файлу."""
        if filename:
            return self._output_dir / filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        return self._output_dir / f"report_{timestamp}.html"
--------------------------------------------------------------------------------
Путь: reports\pdf_report.py
Имя файла: pdf_report.py
Содержимое:
# reports/pdf_report.py
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional, List, Tuple

from reportlab.lib import colors
from reportlab.lib.pagesizes import A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import cm
from reportlab.platypus import (
    SimpleDocTemplate,
    Table,
    TableStyle,
    Paragraph,
    Spacer
)

from db.database import Database
from db.queries import WORK_ORDERS_FOR_PDF_HTML
from utils.validators import validate_date_range

logger = logging.getLogger(__name__)


class PDFReportGenerator:
    """Генератор PDF-отчетов с расширенными возможностями фильтрации."""

    def __init__(self, db: Database):
        self.db = db
        self._output_dir = Path("reports/pdf")
        self._output_dir.mkdir(exist_ok=True, parents=True)
        self.styles = self._create_custom_styles()

    def generate(
            self,
            filters: Optional[Dict] = None,
            filename: Optional[str] = None
    ) -> Optional[str]:
        """Генерирует PDF-отчет с применением фильтров."""
        try:
            data = self._get_filtered_data(filters)
            if not data:
                logger.warning("Нет данных для формирования отчета")
                return None

            output_path = self._get_output_path(filename)
            doc = SimpleDocTemplate(
                str(output_path),
                pagesize=A4,
                leftMargin=2 * cm,
                rightMargin=2 * cm
            )

            elements = []
            self._add_header(elements)
            self._add_filters_info(elements, filters)
            self._add_data_table(elements, data)
            self._add_footer(elements)

            doc.build(elements)
            return str(output_path)

        except Exception as e:
            logger.error(f"Ошибка генерации PDF: {str(e)}")
            return None

    def _get_filtered_data(self, filters: Optional[Dict]) -> List[Tuple]:
        """Получение данных с применением фильтров."""
        query = WORK_ORDERS_FOR_PDF_HTML
        params = []

        if filters:
            where_clauses = []
            for key, value in filters.items():
                if value:
                    if key == "date_range":
                        if validate_date_range(value["start"], value["end"]):
                            where_clauses.append(
                                "order_date BETWEEN ? AND ?"
                            )
                            params.extend([value["start"], value["end"]])
                    elif key == "contract":
                        where_clauses.append("contract_code = ?")
                        params.append(value)
                    elif key == "product":
                        where_clauses.append("product_name = ?")
                        params.append(value)
                    elif key == "worker":
                        where_clauses.append("workers LIKE ?")
                        params.append(f"%{value}%")

            if where_clauses:
                query += " WHERE " + " AND ".join(where_clauses)

        return self.db.execute_query(query, tuple(params)) or []

    def _create_custom_styles(self) -> Dict:
        """Создание кастомных стилей для отчета."""
        styles = getSampleStyleSheet()
        styles.add(ParagraphStyle(
            name="Title",
            fontSize=14,
            leading=16,
            alignment=1,
            spaceAfter=12
        ))
        styles.add(ParagraphStyle(
            name="Footer",
            fontSize=8,
            textColor=colors.grey,
            alignment=2
        ))
        return styles

    def _add_header(self, elements: List) -> None:
        """Добавление заголовка отчета."""
        title = Paragraph(
            "Отчет по нарядам работ",
            self.styles["Title"]
        )
        elements.append(title)
        elements.append(Spacer(1, 0.5 * cm))

    def _add_filters_info(self, elements: List, filters: Dict) -> None:
        """Добавление информации о примененных фильтрах."""
        if filters:
            filter_text = "Примененные фильтры: " + ", ".join(
                [f"{k}: {v}" for k, v in filters.items() if v]
            )
            elements.append(Paragraph(filter_text, self.styles["Normal"]))
            elements.append(Spacer(1, 0.2 * cm))

    def _add_data_table(self, elements: List, data: List[Tuple]) -> None:
        """Создание основной таблицы с данными."""
        headers = [
            "Наряд №",
            "Дата",
            "Изделие",
            "Контракт",
            "Сумма",
            "Рабочие"
        ]

        table_data = [headers]
        for row in data:
            formatted_row = [
                str(row[0]),
                datetime.strptime(row[1], "%Y-%m-%d").strftime("%d.%m.%Y"),
                row[2],
                row[3],
                f"{row[4]:,.2f} ₽".replace(",", " "),
                ", ".join(row[5].split(", "))
            ]
            table_data.append(formatted_row)

        table = Table(
            table_data,
            colWidths=[2 * cm, 2.5 * cm, 4 * cm, 4 * cm, 3 * cm, 6 * cm],
            repeatRows=1
        )

        table.setStyle(TableStyle([
            ("BACKGROUND", (0, 0), (-1, 0), colors.lightgrey),
            ("TEXTCOLOR", (0, 0), (-1, 0), colors.black),
            ("ALIGN", (0, 0), (-1, -1), "CENTER"),
            ("FONTNAME", (0, 0), (-1, 0), "Helvetica-Bold"),
            ("FONTSIZE", (0, 0), (-1, 0), 10),
            ("BOTTOMPADDING", (0, 0), (-1, 0), 12),
            ("GRID", (0, 0), (-1, -1), 1, colors.black),
            ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
        ]))

        elements.append(table)

    def _add_footer(self, elements: List) -> None:
        """Добавление подвала отчета."""
        footer_text = Paragraph(
            f"Сформировано: {datetime.now().strftime('%d.%m.%Y %H:%M')}",
            self.styles["Footer"]
        )
        elements.append(Spacer(1, 1 * cm))
        elements.append(footer_text)

    def _get_output_path(self, filename: Optional[str]) -> Path:
        """Генерация пути для сохранения файла."""
        if filename:
            return self._output_dir / filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        return self._output_dir / f"report_{timestamp}.pdf"
--------------------------------------------------------------------------------
Путь: tests\test_database.py
Имя файла: test_database.py
Содержимое:
import sqlite3

import pytest
from pathlib import Path
from db.database import Database
from db.backup import BackupManager

TEST_DB_PATH = "test_work_orders.db"


@pytest.fixture(scope="function")
def test_db():
    """Фикстура для создания и удаления тестовой БД."""
    db_path = Path(TEST_DB_PATH)

    # Удаление старой БД
    if db_path.exists():
        db_path.unlink(missing_ok=True)

    # Создание новой БД
    db = Database()
    db.db_path = TEST_DB_PATH
    db._init_db()  # Создает файл через Path.touch()

    # Явное создание таблиц и данных
    with db.conn:
        cursor = db.conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS employees (
                id INTEGER PRIMARY KEY,
                employee_id TEXT UNIQUE NOT NULL,
                full_name TEXT NOT NULL,
                workshop_number INTEGER NOT NULL,
                position TEXT NOT NULL
            )
        """)
        cursor.execute(
            "INSERT INTO employees (employee_id, full_name, workshop_number, position) VALUES (?, ?, ?, ?)",
            ("dummy", "Тест", 0, "Тест")
        )
        db.conn.commit()

    # Закрываем соединение, чтобы файл разблокировался
    db.conn.close()

    yield db

    # Удаление БД
    if db_path.exists():
        db_path.unlink()


def test_create_tables(test_db):
    """Проверка создания таблиц."""
    # Переоткрываем соединение для теста
    test_db.conn = sqlite3.connect(TEST_DB_PATH)
    test_db.execute_query("DELETE FROM employees")

    test_db.execute_query(
        "INSERT INTO employees (employee_id, full_name, workshop_number, position) VALUES (?, ?, ?, ?)",
        ("001", "Иванов Иван", 1, "Инженер")
    )
    result = test_db.execute_query("SELECT * FROM employees")
    assert len(result) == 1, "Данные не добавлены в таблицу."
    test_db.conn.close()


def test_backup_manager(test_db):
    """Проверка создания резервных копий."""
    # Проверка существования файла БД
    assert Path(TEST_DB_PATH).exists(), "Файл БД не создан!"

    # Создание BackupManager
    manager = BackupManager(TEST_DB_PATH, backup_dir="test_backups", max_backups=2)
    backup_path = manager.create_backup()

    # Проверки
    assert backup_path is not None, "Резервная копия не создана."
    assert Path(backup_path).exists(), "Файл резервной копии отсутствует."

    # Очистка
    for file in Path("test_backups").glob("*.db"):
        file.unlink()
    Path("test_backups").rmdir()
--------------------------------------------------------------------------------
Путь: utils\excel_handler.py
Имя файла: excel_handler.py
Содержимое:
# utils/excel_handler.py
import pandas as pd
from pathlib import Path
from typing import Optional, List, Dict
from db.database import Database
import logging

logger = logging.getLogger(__name__)


class ExcelHandler:
    """Класс для импорта/экспорта данных из Excel."""

    def __init__(self, db: Database):
        self.db = db
        self.supported_tables = {
            "employees": ("ФИО", "Номер цеха", "Должность", "Табельный номер"),
            "work_types": ("Наименование", "Единица измерения", "Цена")
        }

    def export_table(self, table_name: str, output_path: Path) -> bool:
        """Экспорт таблицы БД в Excel."""
        if table_name not in self.supported_tables:
            logger.error(f"Таблица {table_name} не поддерживается")
            return False

        try:
            data = self.db.execute_query(f"SELECT * FROM {table_name}")
            if not data:
                return False

            df = pd.DataFrame(data, columns=self.supported_tables[table_name])
            df.to_excel(output_path, index=False)
            return True

        except Exception as e:
            logger.error(f"Ошибка экспорта: {str(e)}")
            return False

    def import_table(self, table_name: str, file_path: Path) -> tuple[bool, str]:
        """Импорт данных из Excel в БД."""
        if table_name not in self.supported_tables:
            return (False, f"Таблица {table_name} не поддерживается")

        try:
            df = pd.read_excel(file_path)
            if not self._validate_columns(df, table_name):
                return (False, "Неверная структура файла")

            # Валидация и преобразование данных
            for _, row in df.iterrows():
                self._process_row(table_name, row)

            return (True, "Успешный импорт")

        except Exception as e:
            return (False, f"Ошибка: {str(e)}")

    def _validate_columns(self, df: pd.DataFrame, table_name: str) -> bool:
        """Проверяет соответствие столбцов."""
        expected = set(self.supported_tables[table_name])
        actual = set(df.columns)
        return expected == actual

    def _process_row(self, table_name: str, row: pd.Series) -> None:
        """Обрабатывает строку данных."""
        # Пример для таблицы работников
        if table_name == "employees":
            self.db.execute_query(
                """INSERT INTO employees (full_name, workshop_number, position, employee_id)
                   VALUES (?, ?, ?, ?)
                   ON CONFLICT(employee_id) DO NOTHING""",
                (row["ФИО"], row["Номер цеха"], row["Должность"], row["Табельный номер"])
            )
--------------------------------------------------------------------------------
Путь: utils\validators.py
Имя файла: validators.py
Содержимое:
# utils/validators.py
from datetime import datetime
from db.database import Database
from typing import Optional, Tuple


def validate_date(date_str: str) -> bool:
    """Проверяет корректность даты в формате DD.MM.YYYY."""
    try:
        datetime.strptime(date_str, "%d.%m.%Y")
        return True
    except ValueError:
        return False


def validate_positive_number(value: str, is_float: bool = False) -> bool:
    """Проверяет, что значение является положительным числом (целым или дробным)."""
    try:
        number = float(value) if is_float else int(value)
        return number > 0
    except (ValueError, TypeError):
        return False


def validate_unique(field: str, value: str, table: str, db: Database) -> bool:
    """Универсальная проверка уникальности значения в указанной таблице."""
    result = db.execute_query(
        f"SELECT COUNT(*) FROM {table} WHERE {field} = ?",
        (value,)
    )
    return result[0][0] == 0 if result else False


def validate_unique_employee_id(employee_id: str, db: Database) -> bool:
    """Проверяет уникальность табельного номера."""
    return validate_unique("employee_id", employee_id, "employees", db)


def validate_unique_contract_code(code: str, db: Database) -> bool:
    """Проверяет уникальность шифра контракта."""
    return validate_unique("contract_code", code, "contracts", db)


def validate_unique_work_type_name(name: str, db: Database) -> bool:
    """Проверяет уникальность наименования вида работ."""
    return validate_unique("name", name, "work_types", db)


def validate_order_data(
        date: str,
        workers: list,
        works: list,
        db: Database
) -> Tuple[bool, Optional[str]]:
    """Комплексная проверка данных наряда."""
    errors = []

    if not validate_date(date):
        errors.append("Неверный формат даты. Используйте ДД.ММ.ГГГГ")

    if not workers:
        errors.append("Выберите хотя бы одного рабочего")

    for work in works:
        if not validate_positive_number(str(work["quantity"])):
            errors.append("Количество работ должно быть положительным числом")

    return (False, "\n".join(errors)) if errors else (True, None)
--------------------------------------------------------------------------------
